using System.Collections;
using System.Collections.Generic;
using Unity.Netcode;
using UnityEngine;

public enum YutResult
{
    Do,
    Gae,
    Gur,
    Yut,
    Mo,
    BackDo,
    Error
}
public class YutManager : NetworkBehaviour
{
    [SerializeField] Yut yutPrefab;
    [SerializeField] GameObject yutResultContent;
    [SerializeField] YutResults yutResultPrefab;
    [SerializeField] Transform yutSpawnTransform;
    [SerializeField] LayerMask ground;

    List<Yut> yuts = new List<Yut>();
    List<YutResult> results = new List<YutResult>();

    int faceDown = 0;
    float throwPower = 10;
    float torque = 3;
    float yutSpacing = 2;
    float waitTime = 10;
    float waitInterval = 1;
    bool backDo = false;

    public int yutNum = 4;
    public int throwChance = 0;

    //싱글톤 아님
    static YutManager instance;
    static public YutManager Instance
    {
        get
        {
            return instance;
        }
    }

    public override void OnNetworkSpawn()
    {
        //서버에서만 윷 소환
        if (!IsServer) return;

        Vector3 pos = yutSpawnTransform.position;

        for (int i = 0; i < yutNum; i++)
        {
            //윷 소환하고
            yuts.Add(Instantiate(yutPrefab));
            
            Yut yut = yuts[i];
            //윷 전체의 중심 위치 맞추기 위한 똥꼬쇼
            yut.transform.position = pos + new Vector3(0, 0, -((yutNum - 1) * yutSpacing) / 2);
            yut.GetComponent<NetworkObject>().Spawn();

            //위치 잡아주고
            if (i > 0)
            {
                yut.transform.position = yuts[i - 1].transform.position + new Vector3(0, 0, yutSpacing);
            }

            //초기화된 위치 저장
            yut.originPos = yut.transform.position;
            yut.originRot = yut.transform.rotation;

            //안보이게 하기
            //yut.gameObject.SetActive(false);
        }
    }

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.R))
        {
            MyTurn();
        }
    }

    void MyTurn()
    {
        throwChance = 1;
        Debug.Log("내턴, 던질 기회 +1");
    }

    public void ThrowButtonPressed()
    {
        //지금 누구 턴인지
        //던질 기회가 남았는지
        if (throwChance < 1)
        {
            Debug.Log("던질 기회 없음");
            return;
        }
        //윷 몇개 던질지 확인
        ThrowYutsServerRpc(yutNum, new ServerRpcParams());
        throwChance--;
        Debug.Log("던짐");
    }

    [ServerRpc(RequireOwnership = false)]
    void ThrowYutsServerRpc(int yutNums, ServerRpcParams rpcParams)
    {
        backDo = false;
        faceDown = 0;
        for(int i = 0; i < yutNums; i++)
        {
            Yut yut = yuts[i];

            //윷을 원래 위치로 돌리기
            yut.transform.localPosition = yut.originPos; //외않됢?
            yut.transform.localRotation = yut.originRot; //외않됢? 이제 됢!

            //보이게 하기
            //yut.gameObject.SetActive(true);

            //윷 던지기
            //던지기 전에 움직임을 없애고(이상한 방향으로 날라가는거 방지)
            yut.Rigidbody.linearVelocity = Vector3.zero;
            yut.Rigidbody.angularVelocity = Vector3.zero;
            //윷에 힘을 가해 위쪽 방향으로 던지고, 랜덤한 토크를 가해 앞 뒷면을 조절한다
            yut.Rigidbody.AddForce(Vector3.up * throwPower, ForceMode.Impulse);
            yut.Rigidbody.AddTorque(yut.transform.forward * Random.Range(-torque, torque), ForceMode.Impulse);
        }

        StartCoroutine(YutResultCheck(0, yutNums, rpcParams));
    }

    IEnumerator YutResultCheck(float timePassed, int yutNums, ServerRpcParams rpcParams)
    {
        ulong senderId = rpcParams.Receive.SenderClientId;

        bool yutStable = false;

        //일정 시간동안 반복
        //waitTime 안에 결과가 안나오면 에러남
        while (timePassed < waitTime)
        {
            //1초마다 윷 상태를 확인
            yield return new WaitForSecondsRealtime(waitInterval);

            for(int i = 0; i < yutNums; i++)
            {
                Yut yut = yuts[i];

                //윷이 멈춰있으면 결과 확인 가능한걸로 판단 -> 완전히 안멈추면 결과 안나옴
                if(yut.Rigidbody.linearVelocity == Vector3.zero && yut.Rigidbody.angularVelocity == Vector3.zero)
                {
                    //다 멈추면 true로 유지
                    yutStable = true;
                }
                else
                {
                    //하나라도 안멈춰있으면 루프 지속
                    yutStable = false;
                }
            }

            if (yutStable)
            {
                for(int i = 0; i<yutNums; i++)
                {
                    Yut yut = yuts[i];

                    //레이캐스트 해서 앞뒷면 계산
                    //윷 결과 계산
                    if (CalcYutResult(yut))
                    {
                        //백도 계산
                        if (i == 0)
                        {
                            backDo = true;
                        }

                        faceDown++;
                        //Debug.Log("뒷면 +1, 총 개수 : " + faceDown);
                    }
                }
                break;
            }

            timePassed += waitInterval;
        }

        //Debug.Log("총 개수 : " + faceDown);
        if (!yutStable)
        {
            Debug.Log("결과 산출 실패 : 타임아웃");
            //타임아웃나면 다시 던질 수 있게 기회 더 줌
            ThrowChanceChangeClientRpc(1, senderId);

            yield break;
        }

        switch (faceDown)
        {
            case 0:
                AddYutResultClientRpc(YutResult.Mo, senderId);
                ThrowChanceChangeClientRpc(1, senderId);
                break;
            case 1:
                if (backDo)
                {
                    AddYutResultClientRpc(YutResult.BackDo, senderId);
                    break;
                }
                AddYutResultClientRpc(YutResult.Do, senderId);
                break;
            case 2:
                AddYutResultClientRpc(YutResult.Gae, senderId);
                break;
            case 3:
                AddYutResultClientRpc(YutResult.Gur, senderId);
                break;
            case 4:
                AddYutResultClientRpc(YutResult.Yut, senderId);
                ThrowChanceChangeClientRpc(1, senderId);
                break;
            default:
                AddYutResultClientRpc(YutResult.Error, senderId);
                break;
        }
    }

    bool CalcYutResult(Yut yut)
    {
        RaycastHit hit;
        Debug.DrawRay(yut.transform.position, yut.transform.right * 10, Color.red, 0.3f);
        if (Physics.Raycast(yut.transform.position, yut.transform.right, out hit, 10, ground))
        {
            //Debug.Log("뒷면임");
            return true;
        }
        //Debug.Log("앞면임");
        return false;
    }

    [ClientRpc]
    void AddYutResultClientRpc(YutResult result, ulong senderId)
    {
        //Debug.Log("로컬 클라이언트 id : " + NetworkManager.Singleton.LocalClientId + "\nrpc요청 id : " + senderId + "\n오너 클라이언트 id : " + OwnerClientId);

        //윷 던지는거 요청한 클라이언트의 윷 결과창을 갱신
        if (senderId == NetworkManager.Singleton.LocalClientId)
        {
            results.Add(result);
            Instantiate(yutResultPrefab, yutResultContent.transform).SetYutText(result);
        }
    }

    [ClientRpc]
    void ThrowChanceChangeClientRpc(int num, ulong senderId)
    {
        //해당 클라이언트의 윷 던지기 횟수를 갱신
        if(senderId == NetworkManager.Singleton.LocalClientId)
        {
            throwChance += num;
        }
    }
}
